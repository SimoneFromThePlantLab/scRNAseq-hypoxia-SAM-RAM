# Load packages ####
library(Seurat)

# Load data ####
## Read expression matrices generated by Cellranger
### Cellranger v3+
mydata <- Read10X("ROOT/filtered_feature_bc_matrix/", gene.column = 1)

#calculate percentage of zero counts
total.zeros <- sum(mydata==0) 
total.counts <- nrow(mydata) * ncol(mydata)
(total.zeros/total.counts) * 100

# Clean data
# Remove cells with < 200 expressed genes
# Remove genes expressed in < 3 cells
# we ask to make a Seura object with read counts and the filter parameters
#ogni volta che carichi un ROOTple chiamalo "serautObjX", dove X è il numero del campione
ROOT <- CreateSeuratObject(counts=mydata,
                           min.cells=3,
                           min.features=200)

#let's now check the dimensions after the filtering
dim(ROOT)
head(ROOT@meta.data) #here I see all the counts for all the genes in each cell (rows)

#how to obtain the counts from the first 5 genes in first 5 cells 
ROOT@assays$RNA@layers$counts[1:5, 1:5]

#how to obtain the counts from the first 5 genes in first 5 cells 
Cells(ROOT)[1:5]
#ROOTe as
colnames(ROOT)[1:5]
#to visualize the last 5 cells
tail(Cells(ROOT), n=5)

#to visualize the first 5 genes
Features(ROOT)[1:5]
tail(Features(ROOT))
#ROOTe as
rownames(ROOT)[1:5]

#remove large variables
rm(total.counts)
rm(total.zeros)
rm(mydata)

ROOT$ROOTple <- "ROOT"
#Number of cells for every ROOTple
table(ROOT$ROOTple)

# Quality control of cells ####
## Calculate % mitochondrial transcripts
head(ROOT@meta.data)
#with the next command we look for mitochondrial genes; for Arabidopsis is not "^mt" but "^ATMG"
?PercentageFeatureSet
ROOT$mito <- PercentageFeatureSet(ROOT,pattern="^ATMG") #we look at the genes that start with mt 
ROOT$chloro <- PercentageFeatureSet(ROOT,pattern="^ATCG")
head(ROOT@meta.data)

#Look in literature and use features argument

#Create data frame for plotting
ROOT_data <- as.data.frame(ROOT@meta.data)

## Create violin plots 
library(patchwork)
library(ggplot2)

#Total number of UMIs
p1 <- ggplot(ROOT_data,aes("",nCount_RNA)) +
  geom_jitter(height=0,width=0.3,color="lightblue") +
  geom_violin(fill="gray80",alpha=0.5) + 
  scale_y_continuous(trans="log2",breaks=c(15000,
                                           30000,65000,
                                           130000,250000)) +
  labs(title="Total UMI counts per cell") +
  theme_classic()

#plotting number of expressed genes
p2 <- ggplot(ROOT_data,aes("",nFeature_RNA)) +
  geom_jitter(height=0,width=0.3,color="lightblue") +
  geom_violin(fill="gray80",alpha=0.5) + 
  scale_y_continuous(trans="log2",breaks=c(2000,
                                           4000,8000,10000)) +
  labs(title="Number of genes per cell") +
  theme_classic()

#plotting % mito transcripts
p3 <- ggplot(ROOT_data,aes("",mito)) +
  geom_jitter(height=0,width=0.3,color="lightblue") +
  geom_violin(fill="gray80",alpha=0.5) +
  labs(title="% of mito transcripts") +
  theme_classic()

#plotting % chloroplast transcripts
p4 <- ggplot(ROOT_data,aes("",chloro)) +
  geom_jitter(height=0,width=0.3,color="lightblue") +
  geom_violin(fill="gray80",alpha=0.5) +
  labs(title="% of mito transcripts") +
  theme_classic()

tiff("ROOT_violin_plots.tiff", units="in", width=14, height=12, res=300)

p1 + p2 + p3 + p4 + plot_layout(nrow=2)

dev.off()

#You can mark or remove outliers: we will flag
#Mark the outlier cells (especially those with low values)
#Adjust the threshold based on the violin plots
ROOT_data$low.features <- ROOT_data$nFeature_RNA < 300
sum(ROOT_data$low.features) #here we see how many cells are flagged

#If you want to remove cells with high % mito
#seuratObj <- subset(seuratObj,mito < 25)

# Remove obsolete variables
rm(ROOT_data)

# NORMALIZATION ####
?NormalizeData
ROOT <- NormalizeData(ROOT)

#Retrieve raw and normalized counts
ROOT@assays$RNA@layers$counts[1:5,1:10]
ROOT@assays$RNA@layers$data[1:5,1:10]

#Normalization of all ROOTples simultaneously?
SOList <- lapply(SOList, NormalizeData)

# Find highly variable genes #### top 2000 variable genes
?FindVariableFeatures
ROOT <- FindVariableFeatures(ROOT)

#Retrieve variable genes and plot
length(VariableFeatures(ROOT))
head(HVFInfo(ROOT))
top20 <- head(VariableFeatures(ROOT),20)

tiff("HVG_ROOT.tiff", units="in", width=10, height=10, res=300)

LabelPoints(plot=VariableFeaturePlot(ROOT),
            points=top20,repel=T)

dev.off()

# SCALING ####
?ScaleData
ROOT <- ScaleData(ROOT)

#retrieve scaled counts
ROOT@assays$RNA@layers$scale.data[1:5,1:4]
dim(ROOT@assays$RNA@layers$scale.data) #the scaling is automatically done for the 2k most varibale genes

# PCA #### all the analysis will be done on the 2k most variable genes
?RunPCA
ROOT <- RunPCA(ROOT,nfeatures.print=10) #here I visualize only 10 genes

#Retrieve results of PCA
ROOT@reductions
ROOT@reductions$pca@cell.embeddings[1:5,1:5] #here I see where every cell will end up in the PCA Plot
ROOT@reductions$pca@feature.loadings[1:5,1:5]

#PCA plot
tiff("PCA_ROOT.tiff", units="in", width=5, height=5, res=300)

  DimPlot(ROOT,reduction="pca")

dev.off()

tiff("PCA_ROOT_3_4.tiff", units="in", width=5, height=5, res=300)

  DimPlot(ROOT,dims=c(3,4),reduction="pca")

dev.off()

# Heat maps of the PCs #### only the cells on the extremes of the PC will be showed in the plot
?DimHeatmap 

tiff("PC_heatmap_PCA.tiff", units="in", width=10, height=18, res=300)

  DimHeatmap(ROOT,dims=1:40,cells=500,balanced=TRUE) #plot the first 12 PC

dev.off()

# Elbow plot of the PCs ####
?ElbowPlot

tiff("elbow_plot.tiff", units="in", width=10, height=10, res=300)

  ElbowPlot(ROOT,ndims=50)

dev.off()

# CLUSTERING ####
## Building kNN/SNN graph
?FindNeighbors
ROOT <- FindNeighbors(ROOT,dims=1:22) #30 PERCHE' SONO LE PC CHE ABBIAMO SELEZIONATO SOPRA

#Different setting for dims: graph.name argument
seuratObj <- FindNeighbors(seuratObj,dims=1:35,
                           graph.name=c("RNA_nn35","RNA_snn35")) #qui invece provo con più PC, ma è importantissimo stabilire il graph.name perchè sennò andrebbe a sovrascrivere quello esistente

#Names of the nn graphs?
names(ROOT@graphs)

## Graph-based clustering
?FindClusters
#set resolution ##very important to set the graph.name on which you want to work 
# RESOLUTION IS CRUCIAL <- set in between 0.4/1.2 #THE HIGHER YOU SET IT, THE MUCH CLUSTERS YOU WILL FIND
ROOT <- FindClusters(ROOT,resolution=0.4,
                     graph.name="RNA_snn") 
#modularity: -0.5 (bad) to 1 (good)
#how dense are lines in clusters compared to between clusters
#0.4 <- 21 clusters
#0.8 <- 27 clusters
#Questions: Try different resolutions


#Retrieve cluster info: all resolutions are in meta data
head(ROOT@meta.data) 
#la colonna seraut_clusters farà riferimento sempre all'ultima risoluzione settata per la clusterizzazione

#After testing several resolutions, visualize results
library(clustree)

tiff("clustree_ROOT_1.tiff", units="in", width=10, height=10, res=300)

  clustree(ROOT@meta.data,prefix="RNA_snn_res.") #mi dice come cambiano i cluster fra le diverse risoluzioni

dev.off()  

# Create UMAP plot ####
?RunUMAP
?RunTSNE

#n.neighbors matches k.param in FindNeighbors()
ROOT <- RunUMAP(ROOT,dims=1:22)

#dims = ovviamente basate sul numero di PCA scelto
#n.nerighbors 20 è completamente arbitrario; il default è 30
ROOT <- RunTSNE(ROOT_1,dims=1:18)

#if I write like this, it will automatically use the UMAP and the seurat_cluster column
DimPlot(ROOT)

#Default is color according to last/active clustering! (in this case 0.8 resolution)
DimPlot(ROOT,group.by="RNA_snn_res.0.4", label=TRUE) + NoLegend()

#print UMAP
colors <- colorRampPalette(brewer.pal(12, "Set3"))(13)

tiff("UMAP_plot_ROOT_2.tiff", units="in", width=5, height=5, res=1200)

DimPlot(ROOT, label = TRUE, cols = colors) + NoLegend() + theme(
  panel.border = element_rect(color = "black", fill = NA, size = 1),  # Bordo nero
  panel.background = element_blank(),                                # Rimuovi sfondo
  axis.line = element_line(color = "black")                          # Linee degli assi
)


dev.off()

#print tsne
tiff("tSNE_plot_WT_3.tiff", units="in", width=5, height=5, res=1200)

  DimPlot(myseuratObj_3,reduction="tsne",group.by="RNA_snn_res.0.2", label = T) + NoLegend()

dev.off()

#?batch effects

#UMAP: color cells according to %mito %chloro
tiff("UMAP_mito_WT_3.tiff", units="in", width=5, height=5, res=300)

FeaturePlot(ROOT,feature="chloro",label=TRUE)

dev.off()

#color according to expression of a gene
tiff("genex.tiff", units="in", width=5, height=5, res=600)

FeaturePlot(ROOT,feature="ATXGXXXX", pt.size = 0.05, cols = c("grey", "red")) + NoLegend() + theme(
  panel.border = element_rect(color = "black", fill = NA),  # Bordo nero
  panel.background = element_blank(),                                # Rimuovi sfondo
  axis.line = element_line(color = "black")                          # Linee degli assi
) 

dev.off()


# Find marker genes ####
#FindAllMarkers() takes a very long time
#Use a stringent threshold and downsize clusters
#only.pos = T it means that we are only looking at upregulated genes
#max.cells.per.ident riduce il numero di cellule di ogni cluster a 100 per ridurre notevolmente i tempi di analisi
?FindAllMarkers
ROOT_FAM <- FindAllMarkers(ROOT,min.diff.pct=0.1,only.pos=TRUE,
                           max.cells.per.ident=100)

write.csv(ROOT_FAM, file = "marker_genes.csv")

#For each ROOTple you go through the pipeline up to here
#You try to annotate the clusters in each ROOTple
